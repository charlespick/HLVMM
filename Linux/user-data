#cloud-config

# 1. Write the provisioning script to disk
write_files:
  - path: /usr/local/bin/provisioning-service.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash

      LOGFILE="/var/log/provisioning_service.log"
      exec > >(tee -a "$LOGFILE") 2>&1

      echo "Started Provisioning on [$(hostname)] at [$(date '+%Y-%m-%d %H:%M:%S')] [uptime: $(uptime -p)]"
      
      # Check KVP daemon status - CRITICAL for provisioning
      if ! systemctl is-active --quiet hv-kvp-daemon && ! systemctl is-active --quiet hypervkvpd; then
          echo "ERROR: Hyper-V KVP daemon is not running!"
          echo "ERROR: Please ensure hyperv-daemons package is installed in the golden image."
          systemctl start hv-kvp-daemon 2>/dev/null || systemctl start hypervkvpd 2>/dev/null || true
          sleep 2
          if ! systemctl is-active --quiet hv-kvp-daemon && ! systemctl is-active --quiet hypervkvpd; then
              echo "FATAL: Cannot start Hyper-V KVP daemon. Provisioning cannot continue."
              exit 1
          fi
      fi

      # Function to read a key from Hyper-V KVP using the correct pool and format
      read_hyperv_kvp() {
          local key="$1"
          local kvp_file="/var/lib/hyperv/.kvp_pool_0"
          
          if [[ ! -f "$kvp_file" ]]; then
              return 1
          fi
          
          local nb=$(wc -c < "$kvp_file")
          local nkv=$(( nb / (512+2048) ))
          
          for n in $(seq 0 $(( $nkv - 1 )) ); do
              local offset=$(( $n * (512 + 2048) ))
              local k=$(dd if="$kvp_file" count=512 bs=1 skip=$offset status=none | sed 's/\x0.*//g')
              if [[ "$k" == "$key" ]]; then
                  dd if="$kvp_file" count=2048 bs=1 skip=$(( $offset + 512 )) status=none | sed 's/\x0.*//g'
                  return 0
              fi
          done
          
          return 1
      }

      # Function to write a key-value pair to Hyper-V KVP using the correct pool and format
      write_hyperv_kvp() {
          local key="$1"
          local value="$2"

          # Validate key and value lengths
          if [[ ${#key} -gt 511 || ${#value} -gt 2047 ]]; then
              echo "ERROR: Key or value too long" >&2
              return 1
          fi

          local guest_pool="/var/lib/hyperv/.kvp_pool_1"
          
          if [[ ! -w "$(dirname "$guest_pool")" ]]; then
              echo "ERROR: Cannot write to KVP directory" >&2
              return 1
          fi
          
          # Build the 2560-byte record directly: 512 bytes key + 2048 bytes value
          {
              flock -x 9
              {
                  printf '%s' "$key"
                  dd if=/dev/zero bs=1 count=$((511 - ${#key})) 2>/dev/null
                  printf '\0'
                  printf '%s' "$value"
                  dd if=/dev/zero bs=1 count=$((2047 - ${#value})) 2>/dev/null
                  printf '\0'
              } >> "$guest_pool"
              flock -u 9
          } 9>>"$guest_pool"
      }

      # File to track service phase
      phase_file="/var/lib/hyperv/service_phase_status"

      # Function to initialize the phase file
      initialize_phase_file() {
          # Ensure the directory exists
          mkdir -p "$(dirname "$phase_file")"
          echo "nophasestartedyet" > "$phase_file"
      }

      # Function to read the current phase status
      read_phase_status() {
          if [[ ! -f "$phase_file" ]]; then
              echo "Phase file not found. Initializing..."
              initialize_phase_file
          fi
          current_phase=$(cat "$phase_file")
          echo "Current phase status: $current_phase"
      }

      # Function to update the phase status
      update_phase_status() {
          local phase="$1"
          echo "$phase" > "$phase_file"
      }

      # Function to eject CD-ROM drives
      eject_cdroms() {
          local cidata_device=$(blkid -t LABEL=CIDATA -o device 2>/dev/null | head -1)
          
          if [[ -n "$cidata_device" ]]; then
              # Unmount if necessary
              local mount_point=$(mount | grep "^$cidata_device " | awk '{print $3}')
              [[ -n "$mount_point" ]] && umount "$mount_point" 2>/dev/null
              
              # Eject the device
              eject "$cidata_device" 2>/dev/null
              echo "Ejected CIDATA device: $cidata_device"
          fi
      }

      phase_one() {
          echo "Starting phase one..."
          update_phase_status "phase_one"

          # Eject CD-ROM drives early to prevent interference with reboots
          eject_cdroms

          # Wait until hostprovisioningsystemstate equals waitingforpublickey
          echo "Waiting for host to signal 'waitingforpublickey'..."
          local timeout=300 # 5 minutes
          local elapsed=0
          
          while true; do
              host_state=$(read_hyperv_kvp "hostprovisioningsystemstate")
              
              if [[ "$host_state" == "waitingforpublickey" ]]; then
                  echo "Host is ready for public key exchange"
                  break
              fi
              
              if [[ $elapsed -ge $timeout ]]; then
                  echo "ERROR: Timeout waiting for host to signal 'waitingforpublickey'"
                  return 1
              fi
              
              sleep 5
              elapsed=$((elapsed + 5))
          done

          # Read provisioningsystemmanifest and verify it equals provisioningsystemver1 (note: case sensitive!)
          echo "Verifying provisioning system manifest..."
          manifest=$(read_hyperv_kvp "provisioningsystemmanifest")
          
          if [[ "$manifest" != "provisioningsystemver1" ]]; then
              echo "ERROR: Invalid provisioningsystemmanifest: '$manifest' (expected: 'provisioningsystemver1')"
              return 1
          fi
          
          echo "Provisioning system manifest verified successfully"

          # Generate a public/private key pair
          echo "Generating RSA key pair..."
          key_dir="/var/lib/hyperv/keys"
          mkdir -p "$key_dir"
          private_key="$key_dir/private_key.pem"
          public_key="$key_dir/public_key.pem"
          
          # Generate 2048-bit RSA key pair
          openssl genpkey -algorithm RSA -out "$private_key" -pkeyopt rsa_keygen_bits:2048
          openssl rsa -pubout -in "$private_key" -out "$public_key"
          
          echo "RSA key pair generated successfully"
          
          # Convert public key to PKCS#1 RSA DER format and then Base64 (compatible with manual parsing on Windows host)
          echo "Converting public key to Base64 format..."
          public_key_der=$(openssl rsa -pubin -in "$public_key" -RSAPublicKey_out -outform DER | base64 -w 0)

          # Publish the public key to guestprovisioningpublickey in KVP
          echo "Publishing public key to KVP..."
          if write_hyperv_kvp "guestprovisioningpublickey" "$public_key_der"; then
              echo "Public key published successfully"
          else
              echo "ERROR: Failed to publish public key"
              return 1
          fi

          # Set guestprovisioningsystemstate to waitingforaeskey (note: correct key name!)
          echo "Setting guest state to 'waitingforaeskey'..."
          if write_hyperv_kvp "guestprovisioningsystemstate" "waitingforaeskey"; then
              echo "Guest state set successfully"
          else
              echo "ERROR: Failed to set guest state"
              return 1
          fi

          # Wait for hostprovisioningsystemstate to equal provisioningdatapublished (note: correct key name!)
          echo "Waiting for host to publish provisioning data..."
          timeout=300 # 5 minutes
          elapsed=0
          
          while true; do
              host_state=$(read_hyperv_kvp "hostprovisioningsystemstate")
              
              if [[ "$host_state" == "provisioningdatapublished" ]]; then
                  echo "Host has published provisioning data"
                  break
              fi
              
              if [[ $elapsed -ge $timeout ]]; then
                  echo "ERROR: Timeout waiting for host to publish provisioning data"
                  return 1
              fi
              
              sleep 5
              elapsed=$((elapsed + 5))
          done

          # Read the shared AES key from KVP
          echo "Reading shared AES key from KVP..."
          shared_aes_key=$(read_hyperv_kvp "sharedaeskey")
          if [[ -z "$shared_aes_key" ]]; then
              echo "ERROR: Shared AES key not found in KVP"
              return 1
          fi

          # Decrypt the AES key using the private key
          echo "Decrypting AES key using RSA private key..."
          decrypted_aes_key=$(echo "$shared_aes_key" | base64 -d | openssl rsautl -decrypt -inkey "$private_key" -pkcs)
          if [[ -z "$decrypted_aes_key" ]]; then
              decrypted_aes_key=$(echo "$shared_aes_key" | base64 -d | openssl rsautl -decrypt -inkey "$private_key")
              if [[ -z "$decrypted_aes_key" ]]; then
                  echo "ERROR: Failed to decrypt AES key"
                  return 1
              fi
          fi
          
          echo "AES key decrypted successfully"

          # Define the keys to decrypt (must match exactly with Windows PowerShell version)
          keys_to_decrypt=(
              "guesthostname"
              "guestv4ipaddr"
              "guestv4cidrprefix"
              "guestv4defaultgw"
              "guestv4dns1"
              "guestv4dns2"
              "guestnetdnssuffix"
              "guestdomainjointarget"
              "guestdomainjoinuid"
              "guestdomainjoinpw"
              "guestdomainjoinou"
              "guestlauid"
              "guestlapw"
          )

          # Directory to store decrypted keys
          decrypted_keys_dir="/var/lib/hyperv/decrypted_keys"
          mkdir -p "$decrypted_keys_dir"

          # Convert decrypted AES key to hex format for OpenSSL
          aes_key_hex=$(echo -n "$decrypted_aes_key" | base64 -d | xxd -p | tr -d '\n')

          # Save each decrypted key to a file
          echo "Decrypting provisioning data keys..."
          for key in "${keys_to_decrypt[@]}"; do
              encrypted_value=$(read_hyperv_kvp "$key")
              if [[ -n "$encrypted_value" ]]; then
                  encrypted_bytes=$(echo "$encrypted_value" | base64 -d)
                  encrypted_len=${#encrypted_bytes}
                  
                  if [[ $encrypted_len -lt 16 ]]; then
                      echo "ERROR: Invalid encrypted data for $key"
                      touch "$decrypted_keys_dir/$key"
                      continue
                  fi
                  
                  # Extract IV (first 16 bytes) and ciphertext
                  iv_hex=$(echo "$encrypted_bytes" | head -c 16 | xxd -p | tr -d '\n')
                  ciphertext_bytes=$(echo "$encrypted_bytes" | tail -c +17)
                  
                  # Decrypt using extracted IV and AES-256-CBC
                  decrypted_value=$(echo -n "$ciphertext_bytes" | openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" -nopad 2>/dev/null | sed 's/\x00*$//')
                  
                  if [[ -z "$decrypted_value" ]]; then
                      decrypted_value=$(echo -n "$ciphertext_bytes" | openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" 2>/dev/null)
                  fi
                  
                  if [[ -n "$decrypted_value" ]]; then
                      echo "$decrypted_value" > "$decrypted_keys_dir/$key"
                  else
                      echo "ERROR: Failed to decrypt value for $key"
                      touch "$decrypted_keys_dir/$key"
                  fi
              else
                  touch "$decrypted_keys_dir/$key"
              fi
          done

          # Function to safely read file content (empty string if file doesn't exist)
          read_file_safe() {
              local file="$1"
              if [[ -f "$file" ]]; then
                  cat "$file"
              else
                  echo ""
              fi
          }

          # Verify the checksum of the provisioning data (must match PowerShell order exactly)
          echo "Verifying provisioning data checksum..."
          
          concatenated_data=$(printf "%s|" \
              "$(read_file_safe "$decrypted_keys_dir/guesthostname")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4ipaddr")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4cidrprefix")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4defaultgw")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4dns1")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4dns2")" \
              "$(read_file_safe "$decrypted_keys_dir/guestnetdnssuffix")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjointarget")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinuid")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinpw")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinou")" \
              "$(read_file_safe "$decrypted_keys_dir/guestlauid")" \
              "$(read_file_safe "$decrypted_keys_dir/guestlapw")")
          concatenated_data=${concatenated_data%|} # Remove trailing pipe

          # Calculate checksum and encode as Base64 (to match Windows version)
          calculated_checksum=$(echo -n "$concatenated_data" | sha256sum -b | awk '{print $1}' | xxd -r -p | base64 -w 0)          
          published_checksum=$(read_hyperv_kvp "provisioningsystemchecksum")

          if [[ "$calculated_checksum" != "$published_checksum" ]]; then
              echo "ERROR: Checksum verification failed!"
              echo "Expected: $published_checksum"
              echo "Got:      $calculated_checksum"
              return 1
          fi

          echo "Checksum verification succeeded."

          # Set the password for the local admin account if both guestlauid and guestlapw are set
          if [[ -f "$decrypted_keys_dir/guestlauid" && -f "$decrypted_keys_dir/guestlapw" ]]; then
              local_admin_user=$(cat "$decrypted_keys_dir/guestlauid")
              local_admin_password=$(cat "$decrypted_keys_dir/guestlapw")

              if [[ -n "$local_admin_user" && -n "$local_admin_password" ]]; then
                  if id "$local_admin_user" &>/dev/null; then
                      echo "$local_admin_user:$local_admin_password" | chpasswd
                      echo "Updated password for existing user: $local_admin_user"
                  else
                      useradd -m -s /bin/bash "$local_admin_user"
                      echo "$local_admin_user:$local_admin_password" | chpasswd
                      # Add to sudo group
                      usermod -aG sudo "$local_admin_user" 2>/dev/null || usermod -aG wheel "$local_admin_user" 2>/dev/null || true
                      echo "Created local admin account: $local_admin_user"
                  fi
              else
                  echo "WARNING: Local admin credentials are empty"
              fi
          else
              echo "INFO: Local admin account not configured (credentials not provided)"
          fi

          # Ignore domain join parameters
          if [[ -f "$decrypted_keys_dir/guestdomainjointarget" || -f "$decrypted_keys_dir/guestdomainjoinuid" || -f "$decrypted_keys_dir/guestdomainjoinpw" ]]; then
              echo "Domain join parameters detected but ignored (not supported on Linux)."
          fi

          # Configure the network with netplan if IP settings are set
          if [[ -f "$decrypted_keys_dir/guestv4ipaddr" && -f "$decrypted_keys_dir/guestv4cidrprefix" && -f "$decrypted_keys_dir/guestv4defaultgw" ]]; then
              ip_address=$(cat "$decrypted_keys_dir/guestv4ipaddr")
              cidr_prefix=$(cat "$decrypted_keys_dir/guestv4cidrprefix")
              default_gateway=$(cat "$decrypted_keys_dir/guestv4defaultgw")
              dns1=$(cat "$decrypted_keys_dir/guestv4dns1")
              dns2=$(cat "$decrypted_keys_dir/guestv4dns2")
              dns_suffix=$(cat "$decrypted_keys_dir/guestnetdnssuffix")

              netplan_config="/etc/netplan/01-netcfg.yaml"
              cat > "$netplan_config" <<EOF
      network:
        version: 2
        ethernets:
          eth0:
            dhcp4: no
            addresses:
              - $ip_address/$cidr_prefix
            gateway4: $default_gateway
            nameservers:
              addresses:
                - $dns1
                - $dns2
              search:
                - $dns_suffix
      EOF
              netplan apply
              echo "Network configured with netplan."
          fi

          # Set the hostname if it is set
          if [[ -f "$decrypted_keys_dir/guesthostname" ]]; then
              hostname=$(cat "$decrypted_keys_dir/guesthostname")
              echo "$hostname" > /etc/hostname
              hostnamectl set-hostname "$hostname"
              echo "Hostname set to $hostname."
          fi
          echo "Phase one completed."
          reboot
      }

      phase_two() {
          echo "Starting phase two..."
          update_phase_status "phase_two"

          # Delete the decrypted KVP data folder
          decrypted_keys_dir="/var/lib/hyperv/decrypted_keys"
          if [[ -d "$decrypted_keys_dir" ]]; then
              rm -rf "$decrypted_keys_dir"
              echo "Deleted decrypted KVP data folder: $decrypted_keys_dir"
          fi

          # Delete the service and copied script
          SERVICE_NAME="provisioning.service"
          TARGET_PATH="/usr/local/bin"
          SCRIPT_NAME="ProvisioningService.sh"

          echo "Phase two completed."

          systemctl disable "$SERVICE_NAME"
          (sleep 2 && systemctl stop "$SERVICE_NAME") &
          rm -f "/etc/systemd/system/$SERVICE_NAME"
          rm -f "$TARGET_PATH/$SCRIPT_NAME"
          systemctl daemon-reload
          echo "Deleted service and copied script."
      }

      read_phase_status
      case "$current_phase" in
          "nophasestartedyet")
              phase_one
              ;;
          "phase_one")
              phase_two
              ;;
          "phase_two")
              echo "All phases are already completed."
              ;;
          *)
              echo "Unknown phase status: $current_phase"
              ;;
      esac

# 2. Write the systemd service unit
  - path: /etc/systemd/system/provisioning.service
    permissions: '0644'
    owner: root:root
    content: |
      [Unit]
      Description=Provisioning Service
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/local/bin/provisioning-service.sh
      Restart=on-failure
      User=root

      [Install]
      WantedBy=multi-user.target

# 3. Start provisioning service
runcmd:
  # Wait a moment for KVP daemon to initialize
  - sleep 5
  - systemctl daemon-reload
  - systemctl enable provisioning.service
  - systemctl start provisioning.service
