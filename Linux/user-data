#cloud-config

# 1. Write the provisioning script to disk
write_files:
  - path: /usr/local/bin/provisioning-service.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash

      LOGFILE="/var/log/provisioning_service.log"
      exec > >(tee -a "$LOGFILE") 2>&1

      echo "Started Provisioning on [$(hostname)] at [$(date '+%Y-%m-%d %H:%M:%S')] [uptime: $(uptime -p)]"
      
      # Check KVP daemon status - CRITICAL for provisioning
      if ! systemctl is-active --quiet hv-kvp-daemon && ! systemctl is-active --quiet hypervkvpd; then
          echo "ERROR: Hyper-V KVP daemon is not running!"
          echo "ERROR: Please ensure hyperv-daemons package is installed in the golden image."
          systemctl start hv-kvp-daemon 2>/dev/null || systemctl start hypervkvpd 2>/dev/null || true
          sleep 2
          if ! systemctl is-active --quiet hv-kvp-daemon && ! systemctl is-active --quiet hypervkvpd; then
              echo "FATAL: Cannot start Hyper-V KVP daemon. Provisioning cannot continue."
              exit 1
          fi
      fi

      # Function to read a key from Hyper-V KVP using the correct pool and format
      read_hyperv_kvp() {
          local key="$1"
          local kvp_file="/var/lib/hyperv/.kvp_pool_0"
          
          if [[ ! -f "$kvp_file" ]]; then
              return 1
          fi
          
          local nb=$(wc -c < "$kvp_file")
          local nkv=$(( nb / (512+2048) ))
          
          for n in $(seq 0 $(( $nkv - 1 )) ); do
              local offset=$(( $n * (512 + 2048) ))
              local k=$(dd if="$kvp_file" count=512 bs=1 skip=$offset status=none | sed 's/\x0.*//g')
              if [[ "$k" == "$key" ]]; then
                  local v=$(dd if="$kvp_file" count=2048 bs=1 skip=$(( $offset + 512 )) status=none | sed 's/\x0.*//g')
                  echo "$v"
                  return 0
              fi
          done
          
          return 1
      }

      # Function to write a key-value pair to Hyper-V KVP using the correct pool and format
      write_hyperv_kvp() {
          local key="$1"
          local value="$2"

          # Validate key and value lengths
          if [[ ${#key} -gt 511 || ${#value} -gt 2047 ]]; then
              echo "ERROR: Key or value too long" >&2
              return 1
          fi

          local guest_pool="/var/lib/hyperv/.kvp_pool_1"
          
          if [[ ! -w "$(dirname "$guest_pool")" ]]; then
              echo "ERROR: Cannot write to KVP directory" >&2
              return 1
          fi
          
          # Build the 2560-byte record directly: 512 bytes key + 2048 bytes value
          {
              flock -x 9
              {
                  printf '%s' "$key"
                  dd if=/dev/zero bs=1 count=$((511 - ${#key})) 2>/dev/null
                  printf '\0'
                  printf '%s' "$value"
                  dd if=/dev/zero bs=1 count=$((2047 - ${#value})) 2>/dev/null
                  printf '\0'
              } >> "$guest_pool"
              flock -u 9
          } 9>>"$guest_pool"
      }

      # File to track service phase
      phase_file="/var/lib/hyperv/service_phase_status"

      # Function to initialize the phase file
      initialize_phase_file() {
          # Ensure the directory exists
          mkdir -p "$(dirname "$phase_file")"
          echo "nophasestartedyet" > "$phase_file"
      }

      # Function to read the current phase status
      read_phase_status() {
          if [[ ! -f "$phase_file" ]]; then
              echo "Phase file not found. Initializing..."
              initialize_phase_file
          fi
          current_phase=$(cat "$phase_file")
          echo "Current phase status: $current_phase"
      }

      # Function to update the phase status
      update_phase_status() {
          local phase="$1"
          echo "$phase" > "$phase_file"
      }

      # Function to copy version file from CD-ROM before ejecting
      copy_version_file() {
          local cidata_device=$(blkid -t LABEL=CIDATA -o device 2>/dev/null | head -1)
          local version_copied=false
          
          if [[ -n "$cidata_device" ]]; then
              # Create temporary mount point
              local temp_mount="/tmp/cidata_mount"
              mkdir -p "$temp_mount"
              
              # Mount the device
              if mount "$cidata_device" "$temp_mount" 2>/dev/null; then
                  echo "Mounted CIDATA device at $temp_mount"
                  
                  # Copy version file if it exists
                  if [[ -f "$temp_mount/version" ]]; then
                      local target_dir="/var/lib/hyperv"
                      mkdir -p "$target_dir"
                      cp "$temp_mount/version" "$target_dir/version"
                      echo "Copied version file from CD-ROM to $target_dir/version"
                      version_copied=true
                  else
                      echo "Warning: Version file not found on CD-ROM"
                  fi
                  
                  # Unmount
                  umount "$temp_mount"
                  rmdir "$temp_mount"
              else
                  echo "Warning: Failed to mount CIDATA device for version file copy"
              fi
          fi
          
          return $([ "$version_copied" = true ] && echo 0 || echo 1)
      }

      # Function to eject CD-ROM drives
      eject_cdroms() {
          local cidata_device=$(blkid -t LABEL=CIDATA -o device 2>/dev/null | head -1)
          
          if [[ -n "$cidata_device" ]]; then
              # Unmount if necessary
              local mount_point=$(mount | grep "^$cidata_device " | awk '{print $3}')
              [[ -n "$mount_point" ]] && umount "$mount_point" 2>/dev/null
              
              # Eject the device
              eject "$cidata_device" 2>/dev/null
              echo "Ejected CIDATA device: $cidata_device"
          fi
      }

      phase_one() {
          echo "Starting phase one..."
          update_phase_status "phase_one"

          # Copy version file from CD-ROM before ejecting
          if ! copy_version_file; then
              echo "ERROR: Failed to copy version file from CD-ROM"
              return 1
          fi

          # Eject CD-ROM drives early to prevent interference with reboots
          eject_cdroms

          # Wait until hostprovisioningsystemstate equals waitingforpublickey
          echo "Waiting for host to signal 'waitingforpublickey'..."
          local timeout=300 # 5 minutes
          local elapsed=0
          
          while true; do
              host_state=$(read_hyperv_kvp "hostprovisioningsystemstate")
              
              if [[ "$host_state" == "waitingforpublickey" ]]; then
                  echo "Host is ready for public key exchange"
                  break
              fi
              
              if [[ $elapsed -ge $timeout ]]; then
                  echo "ERROR: Timeout waiting for host to signal 'waitingforpublickey'"
                  return 1
              fi
              
              sleep 5
              elapsed=$((elapsed + 5))
          done

          # Read expected version from local version file
          local version_file="/var/lib/hyperv/version"
          if [[ ! -f "$version_file" ]]; then
              echo "ERROR: Version file not found at $version_file. Cannot verify provisioning system version."
              return 1
          fi
          
          local expected_version=$(cat "$version_file" | tr -d '\r\n' | xargs)
          if [[ -z "$expected_version" ]]; then
              echo "ERROR: Failed to read version from $version_file. Cannot verify provisioning system version."
              return 1
          fi

          # Read hlvmm.meta.version and verify it matches expected version
          echo "Verifying provisioning system manifest..."
          manifest_raw=$(read_hyperv_kvp "hlvmm.meta.version")
          
          if [[ -z "$manifest_raw" ]]; then
              echo "ERROR: Failed to read hlvmm.meta.version from KVP. Cannot verify provisioning system version."
              return 1
          fi
          
          # Normalize manifest version: trim whitespace, remove null chars and line endings
          manifest=$(echo "$manifest_raw" | tr -d '\0\r\n' | xargs)
          
          if [[ "$manifest" != "$expected_version" ]]; then
              echo "ERROR: Invalid hlvmm.meta.version: '$manifest' (expected: '$expected_version')"
              return 1
          fi
          
          echo "Provisioning system version verified: $expected_version"

          # Generate a public/private key pair
          echo "Generating RSA key pair..."
          key_dir="/var/lib/hyperv/keys"
          mkdir -p "$key_dir"
          private_key="$key_dir/private_key.pem"
          public_key="$key_dir/public_key.pem"
          
          # Generate 2048-bit RSA key pair
          openssl genpkey -algorithm RSA -out "$private_key" -pkeyopt rsa_keygen_bits:2048
          openssl rsa -pubout -in "$private_key" -out "$public_key"
          
          echo "RSA key pair generated successfully"
          
          # Convert public key to PKCS#1 RSA DER format and then Base64 (compatible with manual parsing on Windows host)
          echo "Converting public key to Base64 format..."
          public_key_der=$(openssl rsa -pubin -in "$public_key" -RSAPublicKey_out -outform DER | base64 -w 0)

          # Publish the public key to guestprovisioningpublickey in KVP
          echo "Publishing public key to KVP..."
          if write_hyperv_kvp "guestprovisioningpublickey" "$public_key_der"; then
              echo "Public key published successfully"
          else
              echo "ERROR: Failed to publish public key"
              return 1
          fi

          # Set guestprovisioningsystemstate to waitingforaeskey (note: correct key name!)
          echo "Setting guest state to 'waitingforaeskey'..."
          if write_hyperv_kvp "guestprovisioningsystemstate" "waitingforaeskey"; then
              echo "Guest state set successfully"
          else
              echo "ERROR: Failed to set guest state"
              return 1
          fi

          # Wait for hostprovisioningsystemstate to equal provisioningdatapublished (note: correct key name!)
          echo "Waiting for host to publish provisioning data..."
          timeout=300 # 5 minutes
          elapsed=0
          
          while true; do
              host_state=$(read_hyperv_kvp "hostprovisioningsystemstate")
              
              if [[ "$host_state" == "provisioningdatapublished" ]]; then
                  echo "Host has published provisioning data"
                  break
              fi
              
              if [[ $elapsed -ge $timeout ]]; then
                  echo "ERROR: Timeout waiting for host to publish provisioning data"
                  return 1
              fi
              
              sleep 5
              elapsed=$((elapsed + 5))
          done

          # Read the shared AES key from KVP
          echo "Reading shared AES key from KVP..."
          shared_aes_key=$(read_hyperv_kvp "sharedaeskey")
          if [[ -z "$shared_aes_key" ]]; then
              echo "ERROR: Shared AES key not found in KVP"
              return 1
          fi

          # Decrypt the AES key using the private key
          echo "Decrypting AES key using RSA private key..."
          
          # Use temporary file to handle binary data properly (avoids null byte issues in command substitution)
          temp_aes_key="/tmp/decrypted_aes_key"
          if ! echo "$shared_aes_key" | base64 -d | openssl pkeyutl -decrypt -inkey "$private_key" -pkeyopt rsa_padding_mode:pkcs1 > "$temp_aes_key"; then
              echo "ERROR: Failed to decrypt AES key"
              rm -f "$temp_aes_key"
              return 1
          fi
          
          # Verify the decrypted key has the correct length (32 bytes for AES-256)
          aes_key_size=$(stat -c%s "$temp_aes_key" 2>/dev/null || echo "0")
          if [[ $aes_key_size -ne 32 ]]; then
              echo "ERROR: Decrypted AES key has wrong size: $aes_key_size bytes (expected 32)"
              rm -f "$temp_aes_key"
              return 1
          fi
          
          echo "AES key decrypted successfully (rsa_padding_mode:pkcs1)"
          
          # Debug: Show AES key length for verification
          echo "DEBUG: Decrypted AES key length: $aes_key_size bytes"

          # Define the keys to decrypt (must match exactly with Windows PowerShell version)
          keys_to_decrypt=(
              "guesthostname"
              "guestv4ipaddr"
              "guestv4cidrprefix"
              "guestv4defaultgw"
              "guestv4dns1"
              "guestv4dns2"
              "guestnetdnssuffix"
              "guestdomainjointarget"
              "guestdomainjoinuid"
              "guestdomainjoinpw"
              "guestdomainjoinou"
              "guestlauid"
              "guestlapw"
          )

          # Directory to store decrypted keys
          decrypted_keys_dir="/var/lib/hyperv/decrypted_keys"
          mkdir -p "$decrypted_keys_dir"

          # Convert decrypted AES key to hex format for OpenSSL
          # Read the binary AES key from file and convert to hex
          aes_key_hex=$(xxd -p < "$temp_aes_key" | tr -d '\n')
          
          # Verify AES key length (should be 32 bytes = 64 hex characters for AES-256)
          if [[ ${#aes_key_hex} -ne 64 ]]; then
              echo "ERROR: AES key has invalid length after decryption: ${#aes_key_hex} hex chars (expected 64)"
              rm -f "$temp_aes_key"
              return 1
          fi
          
          echo "AES key successfully processed (${#aes_key_hex} hex characters)"
          
          # Clean up temporary AES key file
          rm -f "$temp_aes_key"

          # Save each decrypted key to a file
          echo "Decrypting provisioning data keys..."
          for key in "${keys_to_decrypt[@]}"; do
              encrypted_value=$(read_hyperv_kvp "$key")
              if [[ -n "$encrypted_value" ]]; then
                  # Use temporary files to handle binary data properly and avoid shell variable issues
                  temp_encrypted="/tmp/encrypted_$key"
                  temp_iv="/tmp/iv_$key"
                  temp_ciphertext="/tmp/ciphertext_$key"
                  
                  # Decode base64 to temporary file
                  echo "$encrypted_value" | base64 -d > "$temp_encrypted"
                  
                  # Check minimum size
                  encrypted_size=$(stat -c%s "$temp_encrypted" 2>/dev/null || echo "0")
                  if [[ $encrypted_size -lt 16 ]]; then
                      echo "ERROR: Invalid encrypted data for $key (size: $encrypted_size bytes)"
                      touch "$decrypted_keys_dir/$key"
                      rm -f "$temp_encrypted" "$temp_iv" "$temp_ciphertext"
                      continue
                  fi
                  
                  # Extract IV (first 16 bytes) and ciphertext using dd
                  dd if="$temp_encrypted" of="$temp_iv" bs=16 count=1 status=none
                  dd if="$temp_encrypted" of="$temp_ciphertext" bs=1 skip=16 status=none
                  
                  # Convert IV to hex
                  iv_hex=$(xxd -p < "$temp_iv" | tr -d '\n')
                  
                  # Decrypt using AES-256-CBC (try with PKCS7 padding first, then no padding)
                  if decrypted_value=$(openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" -in "$temp_ciphertext" 2>/dev/null); then
                      echo "$decrypted_value" > "$decrypted_keys_dir/$key"
                      echo "Successfully decrypted $key"
                  elif decrypted_value=$(openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" -nopad -in "$temp_ciphertext" 2>/dev/null | sed 's/\x00*$//'); then
                      echo "$decrypted_value" > "$decrypted_keys_dir/$key"
                      echo "Successfully decrypted $key (with nopad)"
                  else
                      echo "ERROR: Failed to decrypt value for $key"
                      touch "$decrypted_keys_dir/$key"
                  fi
                  
                  # Clean up temporary files
                  rm -f "$temp_encrypted" "$temp_iv" "$temp_ciphertext"
              else
                  touch "$decrypted_keys_dir/$key"
              fi
          done

          # Function to safely read file content (empty string if file doesn't exist)
          read_file_safe() {
              local file="$1"
              if [[ -f "$file" ]]; then
                  cat "$file"
              else
                  echo ""
              fi
          }

          # Verify the checksum of the provisioning data (must match PowerShell order exactly)
          echo "Verifying provisioning data checksum..."
          
          concatenated_data=$(printf "%s|" \
              "$(read_file_safe "$decrypted_keys_dir/guesthostname")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4ipaddr")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4cidrprefix")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4defaultgw")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4dns1")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4dns2")" \
              "$(read_file_safe "$decrypted_keys_dir/guestnetdnssuffix")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjointarget")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinuid")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinpw")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinou")" \
              "$(read_file_safe "$decrypted_keys_dir/guestlauid")" \
              "$(read_file_safe "$decrypted_keys_dir/guestlapw")")
          concatenated_data=${concatenated_data%|} # Remove trailing pipe

          # Calculate checksum and encode as Base64 (to match Windows version)
          calculated_checksum=$(echo -n "$concatenated_data" | sha256sum -b | awk '{print $1}' | xxd -r -p | base64 -w 0)          
          published_checksum=$(read_hyperv_kvp "provisioningsystemchecksum")

          if [[ "$calculated_checksum" != "$published_checksum" ]]; then
              echo "ERROR: Checksum verification failed!"
              echo "Expected: $published_checksum"
              echo "Got:      $calculated_checksum"
              echo "DEBUG: Concatenated data length: ${#concatenated_data} characters"
              echo "DEBUG: First 100 chars of concatenated data: ${concatenated_data:0:100}"
              return 1
          fi

          echo "Checksum verification succeeded."

          # Configure local admin account if credentials are provided and non-empty
          local_admin_user=$(read_file_safe "$decrypted_keys_dir/guestlauid" | tr -d '\0\r\n' | xargs)
          local_admin_password=$(read_file_safe "$decrypted_keys_dir/guestlapw" | tr -d '\0\r\n' | xargs)

          if [[ -n "$local_admin_user" && -n "$local_admin_password" ]]; then
              if id "$local_admin_user" &>/dev/null; then
                  echo "$local_admin_user:$local_admin_password" | chpasswd
                  echo "Updated password for existing user: $local_admin_user"
              else
                  useradd -m -s /bin/bash "$local_admin_user"
                  echo "$local_admin_user:$local_admin_password" | chpasswd
                  # Add to sudo group for administrative privileges
                  usermod -aG sudo "$local_admin_user" 2>/dev/null || usermod -aG wheel "$local_admin_user" 2>/dev/null || true
                  echo "Created local admin account: $local_admin_user"
              fi
              
              # Ensure the user is in the admin/sudo group
              if groups "$local_admin_user" | grep -qE '\b(sudo|wheel)\b'; then
                  echo "User $local_admin_user has administrative privileges."
              else
                  echo "WARNING: User $local_admin_user may not have administrative privileges."
              fi
          else
              echo "Local admin credentials not provided or incomplete. Skipping local account configuration."
              echo "  Username: ${local_admin_user:-'<empty>'}"
              echo "  Password: ${local_admin_password:+<provided>}${local_admin_password:-<empty>}"
          fi

          # Ignore domain join parameters
          if [[ -f "$decrypted_keys_dir/guestdomainjointarget" || -f "$decrypted_keys_dir/guestdomainjoinuid" || -f "$decrypted_keys_dir/guestdomainjoinpw" ]]; then
              echo "Domain join parameters detected but ignored (not supported on Linux)."
          fi

          # Configure the network with netplan if IP settings are complete and valid
          # Read network configuration values safely
          ip_address=$(read_file_safe "$decrypted_keys_dir/guestv4ipaddr" | tr -d '\0\r\n' | xargs)
          cidr_prefix=$(read_file_safe "$decrypted_keys_dir/guestv4cidrprefix" | tr -d '\0\r\n' | xargs)
          default_gateway=$(read_file_safe "$decrypted_keys_dir/guestv4defaultgw" | tr -d '\0\r\n' | xargs)
          dns1=$(read_file_safe "$decrypted_keys_dir/guestv4dns1" | tr -d '\0\r\n' | xargs)
          dns2=$(read_file_safe "$decrypted_keys_dir/guestv4dns2" | tr -d '\0\r\n' | xargs)
          dns_suffix=$(read_file_safe "$decrypted_keys_dir/guestnetdnssuffix" | tr -d '\0\r\n' | xargs)
          
          # Check if all required network parameters are provided and non-empty
          if [[ -n "$ip_address" && -n "$cidr_prefix" && -n "$default_gateway" ]]; then
              echo "Configuring static network: $ip_address/$cidr_prefix via $default_gateway"
              
              # Function to safely escape YAML values
              yaml_escape() {
                  local value="$1"
                  # If value contains special characters, quote it
                  if [[ "$value" == *[\ \'\"\`\$\!\@\#\%\^\&\*\(\)\[\]\{\}\|\\\;\:\<\>\,\?\~]* ]]; then
                      printf '"%s"' "${value//\"/\\\"}"
                  else
                      printf '%s' "$value"
                  fi
              }
              
              # Build netplan configuration programmatically to avoid templating issues
              netplan_config="/etc/netplan/01-netcfg.yaml"
              
              # Start building the YAML structure
              {
                  echo "network:"
                  echo "  version: 2"
                  echo "  ethernets:"
                  echo "    eth0:"
                  echo "      dhcp4: no"
                  echo "      addresses:"
                  echo "        - $(yaml_escape "$ip_address/$cidr_prefix")"
                  echo "      gateway4: $(yaml_escape "$default_gateway")"
                  
                  # Only add nameservers section if we have at least one DNS server
                  if [[ -n "$dns1" || -n "$dns2" ]]; then
                      echo "      nameservers:"
                      
                      # Add addresses array if we have DNS servers
                      if [[ -n "$dns1" || -n "$dns2" ]]; then
                          echo "        addresses:"
                          [[ -n "$dns1" ]] && echo "          - $(yaml_escape "$dns1")"
                          [[ -n "$dns2" ]] && echo "          - $(yaml_escape "$dns2")"
                      fi
                      
                      # Add search domain if provided
                      if [[ -n "$dns_suffix" ]]; then
                          echo "        search:"
                          echo "          - $(yaml_escape "$dns_suffix")"
                      fi
                  fi
              } > "$netplan_config"
              
              # Validate the generated netplan configuration
              if netplan generate 2>/dev/null; then
                  netplan apply
                  echo "Network configured with netplan successfully."
              else
                  echo "ERROR: Generated netplan configuration is invalid. Keeping DHCP configuration."
                  rm -f "$netplan_config"
              fi
          else
              echo "Network configuration incomplete or missing. Required: IP address, CIDR prefix, and default gateway."
              echo "  IP Address: ${ip_address:-'<empty>'}"
              echo "  CIDR Prefix: ${cidr_prefix:-'<empty>'}"
              echo "  Default Gateway: ${default_gateway:-'<empty>'}"
              echo "Skipping static network configuration - will use DHCP."
          fi

          # Set the hostname if it is provided and non-empty
          hostname=$(read_file_safe "$decrypted_keys_dir/guesthostname" | tr -d '\0\r\n' | xargs)
          if [[ -n "$hostname" ]]; then
              echo "$hostname" > /etc/hostname
              hostnamectl set-hostname "$hostname"
              echo "Hostname set to: $hostname"
          else
              echo "Hostname not provided or empty. Skipping hostname configuration."
          fi
          echo "Phase one completed."
          reboot
      }

      phase_two() {
          echo "Starting phase two..."
          update_phase_status "phase_two"

          # Delete the decrypted KVP data folder
          decrypted_keys_dir="/var/lib/hyperv/decrypted_keys"
          if [[ -d "$decrypted_keys_dir" ]]; then
              rm -rf "$decrypted_keys_dir"
              echo "Deleted decrypted KVP data folder: $decrypted_keys_dir"
          fi

          # Delete the service and copied script
          SERVICE_NAME="provisioning.service"
          TARGET_PATH="/usr/local/bin"
          SCRIPT_NAME="ProvisioningService.sh"

          echo "Phase two completed."

          systemctl disable "$SERVICE_NAME"
          (sleep 2 && systemctl stop "$SERVICE_NAME") &
          rm -f "/etc/systemd/system/$SERVICE_NAME"
          rm -f "$TARGET_PATH/$SCRIPT_NAME"
          systemctl daemon-reload
          echo "Deleted service and copied script."
      }

      read_phase_status
      case "$current_phase" in
          "nophasestartedyet")
              phase_one
              ;;
          "phase_one")
              phase_two
              ;;
          "phase_two")
              echo "All phases are already completed."
              ;;
          *)
              echo "Unknown phase status: $current_phase"
              ;;
      esac

# 2. Write the systemd service unit
  - path: /etc/systemd/system/provisioning.service
    permissions: '0644'
    owner: root:root
    content: |
      [Unit]
      Description=Provisioning Service
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/local/bin/provisioning-service.sh
      Restart=on-failure
      User=root

      [Install]
      WantedBy=multi-user.target

# 3. Start provisioning service
runcmd:
  # Wait a moment for KVP daemon to initialize
  - sleep 5
  - systemctl daemon-reload
  - systemctl enable provisioning.service
  - systemctl start provisioning.service
