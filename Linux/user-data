#cloud-config

# 1. Write the provisioning script to disk
write_files:
  - path: /usr/local/bin/provisioning-service.sh
    permissions: '0755'
    owner: root:root
    content: |
      #!/bin/bash

      LOGFILE="/var/log/provisioning_service.log"
      exec > >(tee -a "$LOGFILE") 2>&1

      echo "Started Provisioning on [$(hostname)] at [$(date '+%Y-%m-%d %H:%M:%S')] [uptime: $(uptime -p)]"
      
      # Check KVP daemon status - CRITICAL for provisioning
      echo "DEBUG: Checking Hyper-V KVP daemon status..."
      kvp_daemon_running=false
      
      if systemctl is-active --quiet hv-kvp-daemon; then
          echo "DEBUG: hv-kvp-daemon is running"
          kvp_daemon_running=true
      elif systemctl is-active --quiet hypervkvpd; then
          echo "DEBUG: hypervkvpd is running"
          kvp_daemon_running=true
      else
          echo "ERROR: Hyper-V KVP daemon is not running!"
          echo "ERROR: This is required for host-guest communication during provisioning."
          echo "ERROR: Please ensure hyperv-daemons package is installed in the golden image."
          systemctl status hv-kvp-daemon 2>/dev/null || systemctl status hypervkvpd 2>/dev/null || echo "DEBUG: No KVP daemon service found"
          
          # Try to start it one more time
          echo "Attempting to start KVP daemon..."
          if systemctl start hv-kvp-daemon 2>/dev/null || systemctl start hypervkvpd 2>/dev/null; then
              sleep 2
              if systemctl is-active --quiet hv-kvp-daemon || systemctl is-active --quiet hypervkvpd; then
                  echo "Successfully started KVP daemon"
                  kvp_daemon_running=true
              fi
          fi
          
          if [[ "$kvp_daemon_running" == false ]]; then
              echo "FATAL: Cannot start Hyper-V KVP daemon. Provisioning cannot continue."
              echo "FATAL: Please install hyperv-daemons package in your golden image."
              exit 1
          fi
      fi
      
      # Check for KVP directory and permissions
      echo "DEBUG: Checking KVP directory and permissions..."
      if [[ -d "/var/lib/hyperv" ]]; then
          echo "DEBUG: Found KVP directory: /var/lib/hyperv"
          ls -la /var/lib/hyperv/ 2>/dev/null || echo "DEBUG: Cannot list /var/lib/hyperv"
      else
          echo "DEBUG: KVP directory not found: /var/lib/hyperv"
      fi

      # Function to read a key from Hyper-V KVP using the correct pool and format
      read_hyperv_kvp() {
          local key="$1"
          echo "DEBUG: Attempting to read KVP key: $key" >&2

          # Only read from pool 0 (host→guest data)
          local kvp_file="/var/lib/hyperv/.kvp_pool_0"
          
          if [[ ! -f "$kvp_file" || ! -r "$kvp_file" ]]; then
              echo "DEBUG: KVP pool 0 file not found or not readable: $kvp_file" >&2
              return 1
          fi

          echo "DEBUG: Reading from KVP pool 0: $kvp_file" >&2
          
          # Read the file in 2560-byte records (512 bytes key + 2048 bytes value)
          local record_size=2560
          local key_size=512
          local value_size=2048
          local file_size=$(stat -c%s "$kvp_file" 2>/dev/null || echo 0)
          
          if [[ $file_size -eq 0 ]]; then
              echo "DEBUG: KVP pool 0 file is empty" >&2
              return 1
          fi
          
          # Calculate number of records
          local num_records=$((file_size / record_size))
          echo "DEBUG: File size: $file_size bytes, Records: $num_records" >&2
          
          # Read each record and check for matching key
          for ((i=0; i<num_records; i++)); do
              local offset=$((i * record_size))
              
              # Extract the key (first 512 bytes, null-terminated)
              local record_key=$(dd if="$kvp_file" bs=1 skip=$offset count=$key_size 2>/dev/null | tr -d '\0' | head -c 511)
              
              if [[ "$record_key" == "$key" ]]; then
                  echo "DEBUG: Found matching key at record $i" >&2
                  
                  # Extract the value (next 2048 bytes, null-terminated)
                  local value_offset=$((offset + key_size))
                  local result=$(dd if="$kvp_file" bs=1 skip=$value_offset count=$value_size 2>/dev/null | tr -d '\0' | head -c 2047)
                  
                  echo "DEBUG: Found key '$key' with value length: ${#result}" >&2
                  echo "$result"
                  return 0
              fi
          done

          echo "DEBUG: Key not found: $key" >&2
          return 1
      }

      # Function to write a key-value pair to Hyper-V KVP using the correct pool and format
      write_hyperv_kvp() {
          local key="$1"
          local value="$2"
          echo "DEBUG: Attempting to write KVP key: $key (value length: ${#value})" >&2

          # Validate key and value lengths
          if [[ ${#key} -gt 511 ]]; then
              echo "ERROR: Key too long (${#key} > 511 characters): $key" >&2
              return 1
          fi
          
          if [[ ${#value} -gt 2047 ]]; then
              echo "ERROR: Value too long (${#value} > 2047 characters)" >&2
              return 1
          fi

          # Only write to pool 1 (guest→host data)
          local guest_pool="/var/lib/hyperv/.kvp_pool_1"
          
          if [[ ! -w "$(dirname "$guest_pool")" ]]; then
              echo "ERROR: Cannot write to KVP directory: $(dirname "$guest_pool")"  >&2
              return 1
          fi

          echo "DEBUG: Writing to KVP pool 1: $guest_pool" >&2
          
          # Create a temporary file for the 2560-byte record
          local temp_record="/tmp/kvp_record_$$"
          
          # Build the 2560-byte record: 512 bytes key + 2048 bytes value
          # Key field: null-terminated string padded to 512 bytes
          printf '%s' "$key" > "$temp_record"
          local key_padding=$((511 - ${#key}))
          if [[ $key_padding -gt 0 ]]; then
              dd if=/dev/zero bs=1 count=$key_padding >> "$temp_record" 2>/dev/null
          fi
          # Add null terminator for key
          printf '\0' >> "$temp_record"
          
          # Value field: null-terminated string padded to 2048 bytes  
          printf '%s' "$value" >> "$temp_record"
          local value_padding=$((2047 - ${#value}))
          if [[ $value_padding -gt 0 ]]; then
              dd if=/dev/zero bs=1 count=$value_padding >> "$temp_record" 2>/dev/null
          fi
          # Add null terminator for value
          printf '\0' >> "$temp_record"
          
          # Verify record size
          local record_size=$(stat -c%s "$temp_record" 2>/dev/null || echo 0)
          if [[ $record_size -ne 2560 ]]; then
              echo "ERROR: Invalid record size: $record_size (expected 2560)" >&2
              rm -f "$temp_record"
              return 1
          fi
          
          # Append the record to pool 1 with file locking
          {
              flock -x 9
              cat "$temp_record" >> "$guest_pool"
              local write_result=$?
              flock -u 9
              
              if [[ $write_result -eq 0 ]]; then
                  echo "DEBUG: Successfully wrote KVP record to pool 1" >&2
                  rm -f "$temp_record"
                  return 0
              else
                  echo "ERROR: Failed to write KVP record to pool 1" >&2
                  rm -f "$temp_record"
                  return 1
              fi
          } 9>>"$guest_pool"
      }

      # File to track service phase
      phase_file="/var/lib/hyperv/service_phase_status"

      # Function to initialize the phase file
      initialize_phase_file() {
          # Ensure the directory exists
          mkdir -p "$(dirname "$phase_file")"
          echo "nophasestartedyet" > "$phase_file"
      }

      # Function to read the current phase status
      read_phase_status() {
          if [[ ! -f "$phase_file" ]]; then
              echo "Phase file not found. Initializing..."
              initialize_phase_file
          fi
          current_phase=$(cat "$phase_file")
          echo "Current phase status: $current_phase"
      }

      # Function to update the phase status
      update_phase_status() {
          local phase="$1"
          echo "$phase" > "$phase_file"
      }

      # Function to eject CD-ROM drives
      eject_cdroms() {
          # Use blkid to find the CIDATA device (same as cloud-init)
          echo "Looking for CIDATA labeled device..."
          local cidata_device=$(blkid -t LABEL=CIDATA -o device 2>/dev/null | head -1)
          
          if [[ -n "$cidata_device" ]]; then
              echo "Found CIDATA device: $cidata_device"
              
              # Check if it's mounted and unmount if necessary
              local mount_point=$(mount | grep "^$cidata_device " | awk '{print $3}')
              if [[ -n "$mount_point" ]]; then
                  echo "CIDATA device is mounted at: $mount_point, unmounting..."
                  if umount "$mount_point" 2>/dev/null; then
                      echo "Successfully unmounted CIDATA device from: $mount_point"
                  else
                      echo "Warning: Failed to unmount CIDATA device from: $mount_point"
                  fi
              fi
              
              # Eject the specific CIDATA device
              if eject "$cidata_device" 2>/dev/null; then
                  echo "Successfully ejected CIDATA device: $cidata_device"
              else
                  echo "Failed to eject CIDATA device: $cidata_device"
              fi
          else
              echo "No CIDATA labeled device found - provisioning ISO already ejected or not present"
          fi
      }

      phase_one() {
          echo "Starting phase one..."
          update_phase_status "phase_one"

          # Eject CD-ROM drives early to prevent interference with reboots
          eject_cdroms

          # Wait until hostprovisioningsystemstate equals waitingforpublickey
          echo "Waiting for host to signal 'waitingforpublickey'..."
          local timeout=300 # 5 minutes
          local elapsed=0
          
          while true; do
              host_state=$(read_hyperv_kvp "hostprovisioningsystemstate")
              echo "DEBUG: hostprovisioningsystemstate = '$host_state' (elapsed: ${elapsed}s)"
              
              if [[ "$host_state" == "waitingforpublickey" ]]; then
                  echo "Host is ready for public key exchange"
                  break
              fi
              
              if [[ $elapsed -ge $timeout ]]; then
                  echo "ERROR: Timeout waiting for host to signal 'waitingforpublickey'"
                  echo "DEBUG: Last host state: '$host_state'"
                  return 1
              fi
              
              sleep 5
              elapsed=$((elapsed + 5))
          done

          # Read provisioningsystemmanifest and verify it equals provisioningsystemver1 (note: case sensitive!)
          echo "Verifying provisioning system manifest..."
          manifest=$(read_hyperv_kvp "provisioningsystemmanifest")
          echo "DEBUG: provisioningsystemmanifest = '$manifest'"
          
          if [[ "$manifest" != "provisioningsystemver1" ]]; then
              echo "ERROR: Invalid provisioningsystemmanifest: '$manifest' (expected: 'provisioningsystemver1')"
              return 1
          fi
          
          echo "Provisioning system manifest verified successfully"

          # TODO: Consider not saving keys to disk, I don't think they need to be kept if we can find a way to keep them in memory in bash

          # Generate a public/private key pair
          echo "Generating RSA key pair..."
          key_dir="/var/lib/hyperv/keys"
          mkdir -p "$key_dir"
          private_key="$key_dir/private_key.pem"
          public_key="$key_dir/public_key.pem"
          
          # Generate 2048-bit RSA key pair
          openssl genpkey -algorithm RSA -out "$private_key" -pkeyopt rsa_keygen_bits:2048
          openssl rsa -pubout -in "$private_key" -out "$public_key"
          
          echo "RSA key pair generated successfully"
          
          # Convert public key to PKCS#1 RSA DER format and then Base64 (compatible with manual parsing on Windows host)
          echo "Converting public key to Base64 format..."
          public_key_der=$(openssl rsa -pubin -in "$public_key" -outform DER | base64 -w 0)
          
          echo "DEBUG: Public key length: ${#public_key_der} characters"
          echo "DEBUG: Public key (first 100 chars): ${public_key_der:0:100}..."

          # Publish the public key to guestprovisioningpublickey in KVP
          echo "Publishing public key to KVP..."
          if write_hyperv_kvp "guestprovisioningpublickey" "$public_key_der"; then
              echo "Public key published successfully"
          else
              echo "ERROR: Failed to publish public key"
              return 1
          fi

          # Set guestprovisioningsystemstate to waitingforaeskey (note: correct key name!)
          echo "Setting guest state to 'waitingforaeskey'..."
          if write_hyperv_kvp "guestprovisioningsystemstate" "waitingforaeskey"; then
              echo "Guest state set successfully"
          else
              echo "ERROR: Failed to set guest state"
              return 1
          fi

          # Wait for hostprovisioningsystemstate to equal provisioningdatapublished (note: correct key name!)
          echo "Waiting for host to publish provisioning data..."
          timeout=300 # 5 minutes
          elapsed=0
          
          while true; do
              host_state=$(read_hyperv_kvp "hostprovisioningsystemstate")
              echo "DEBUG: hostprovisioningsystemstate = '$host_state' (elapsed: ${elapsed}s)"
              
              if [[ "$host_state" == "provisioningdatapublished" ]]; then
                  echo "Host has published provisioning data"
                  break
              fi
              
              if [[ $elapsed -ge $timeout ]]; then
                  echo "ERROR: Timeout waiting for host to publish provisioning data"
                  echo "DEBUG: Last host state: '$host_state'"
                  return 1
              fi
              
              sleep 5
              elapsed=$((elapsed + 5))
          done

          # Read the shared AES key from KVP
          echo "Reading shared AES key from KVP..."
          shared_aes_key=$(read_hyperv_kvp "sharedaeskey")
          if [[ -z "$shared_aes_key" ]]; then
              echo "ERROR: Shared AES key not found in KVP"
              return 1
          fi
          
          echo "DEBUG: Shared AES key length: ${#shared_aes_key} characters"
          echo "DEBUG: Shared AES key (first 100 chars): ${shared_aes_key:0:100}..."

          # Decrypt the AES key using the private key
          echo "Decrypting AES key using RSA private key..."
          decrypted_aes_key=$(echo "$shared_aes_key" | base64 -d | openssl rsautl -decrypt -inkey "$private_key" -pkcs)
          if [[ -z "$decrypted_aes_key" ]]; then
              echo "ERROR: Failed to decrypt AES key using RSA private key"
              echo "DEBUG: Attempting alternative decryption methods..."
              
              # Try different padding options
              decrypted_aes_key=$(echo "$shared_aes_key" | base64 -d | openssl rsautl -decrypt -inkey "$private_key")
              if [[ -z "$decrypted_aes_key" ]]; then
                  echo "ERROR: All AES key decryption methods failed"
                  return 1
              fi
          fi
          
          echo "AES key decrypted successfully"
          echo "DEBUG: Decrypted AES key length: ${#decrypted_aes_key} bytes"

          # Define the keys to decrypt (must match exactly with Windows PowerShell version)
          keys_to_decrypt=(
              "guesthostname"
              "guestv4ipaddr"
              "guestv4cidrprefix"
              "guestv4defaultgw"
              "guestv4dns1"
              "guestv4dns2"
              "guestnetdnssuffix"
              "guestdomainjointarget"
              "guestdomainjoinuid"
              "guestdomainjoinpw"
              "guestdomainjoinou"
              "guestlauid"
              "guestlapw"
          )

          # Directory to store decrypted keys
          decrypted_keys_dir="/var/lib/hyperv/decrypted_keys"
          mkdir -p "$decrypted_keys_dir"

          # Convert decrypted AES key to hex format for OpenSSL
          aes_key_hex=$(echo -n "$decrypted_aes_key" | base64 -d | xxd -p | tr -d '\n')
          echo "DEBUG: AES key hex length: ${#aes_key_hex} characters"

          # Save each decrypted key to a file
          echo "Decrypting provisioning data keys..."
          for key in "${keys_to_decrypt[@]}"; do
              echo "Processing key: $key"
              encrypted_value=$(read_hyperv_kvp "$key")
              if [[ -n "$encrypted_value" ]]; then
                  echo "DEBUG: Encrypted value for $key found (length: ${#encrypted_value})"
                  
                  # Decode base64 and extract IV (first 16 bytes) and ciphertext
                  encrypted_bytes=$(echo "$encrypted_value" | base64 -d)
                  encrypted_len=${#encrypted_bytes}
                  
                  echo "DEBUG: Encrypted bytes length for $key: $encrypted_len"
                  
                  if [[ $encrypted_len -lt 16 ]]; then
                      echo "ERROR: Invalid encrypted data for $key (too short: $encrypted_len bytes)"
                      continue
                  fi
                  
                  # Extract IV (first 16 bytes) and convert to hex
                  iv_hex=$(echo "$encrypted_bytes" | head -c 16 | xxd -p | tr -d '\n')
                  echo "DEBUG: IV for $key: $iv_hex"
                  
                  # Extract ciphertext (remaining bytes)
                  ciphertext_bytes=$(echo "$encrypted_bytes" | tail -c +17)
                  ciphertext_len=${#ciphertext_bytes}
                  echo "DEBUG: Ciphertext length for $key: $ciphertext_len bytes"
                  
                  # Decrypt using extracted IV and AES-256-CBC with PKCS7 padding
                  decrypted_value=$(echo -n "$ciphertext_bytes" | openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" -nopad 2>/dev/null | sed 's/\x00*$//')
                  
                  if [[ -z "$decrypted_value" ]]; then
                      # Try with PKCS7 padding
                      decrypted_value=$(echo -n "$ciphertext_bytes" | openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" 2>/dev/null)
                  fi
                  
                  if [[ -n "$decrypted_value" ]]; then
                      echo "$decrypted_value" > "$decrypted_keys_dir/$key"
                      echo "Successfully decrypted and saved key: $key"
                      echo "DEBUG: Decrypted value for $key (length: ${#decrypted_value}): ${decrypted_value:0:50}..."
                  else
                      echo "ERROR: Failed to decrypt value for $key"
                      echo "DEBUG: OpenSSL error details:"
                      echo -n "$ciphertext_bytes" | openssl enc -d -aes-256-cbc -K "$aes_key_hex" -iv "$iv_hex" 2>&1 || true
                      # Create empty file to maintain consistency
                      touch "$decrypted_keys_dir/$key"
                  fi
              else
                  echo "WARNING: Encrypted value for $key not found. Creating empty file..."
                  # Create empty file to maintain consistency with Windows version
                  touch "$decrypted_keys_dir/$key"
              fi
          done

          # Function to safely read file content (empty string if file doesn't exist)
          read_file_safe() {
              local file="$1"
              if [[ -f "$file" ]]; then
                  cat "$file"
              else
                  echo ""
              fi
          }

          # Verify the checksum of the provisioning data (must match PowerShell order exactly)
          echo "Verifying provisioning data checksum..."
          
          concatenated_data=$(printf "%s|" \
              "$(read_file_safe "$decrypted_keys_dir/guesthostname")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4ipaddr")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4cidrprefix")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4defaultgw")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4dns1")" \
              "$(read_file_safe "$decrypted_keys_dir/guestv4dns2")" \
              "$(read_file_safe "$decrypted_keys_dir/guestnetdnssuffix")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjointarget")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinuid")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinpw")" \
              "$(read_file_safe "$decrypted_keys_dir/guestdomainjoinou")" \
              "$(read_file_safe "$decrypted_keys_dir/guestlauid")" \
              "$(read_file_safe "$decrypted_keys_dir/guestlapw")")
          concatenated_data=${concatenated_data%|} # Remove trailing pipe

          echo "DEBUG: Concatenated data length: ${#concatenated_data} characters"
          echo "DEBUG: Concatenated data (first 200 chars): ${concatenated_data:0:200}..."

          # Calculate checksum and encode as Base64 (to match Windows version)
          calculated_checksum_hex=$(echo -n "$concatenated_data" | sha256sum | awk '{print $1}')
          calculated_checksum=$(echo -n "$concatenated_data" | sha256sum -b | awk '{print $1}' | xxd -r -p | base64 -w 0)
          
          echo "DEBUG: Calculated checksum (hex): $calculated_checksum_hex"
          echo "DEBUG: Calculated checksum (base64): $calculated_checksum"
          
          published_checksum=$(read_hyperv_kvp "provisioningsystemchecksum")
          echo "DEBUG: Published checksum: $published_checksum"

          if [[ "$calculated_checksum" != "$published_checksum" ]]; then
              echo "ERROR: Checksum verification failed!"
              echo "Expected: $published_checksum"
              echo "Got:      $calculated_checksum"
              echo "DEBUG: Data used for checksum:"
              for i in {0..12}; do
                  local field=$(echo "$concatenated_data" | cut -d'|' -f$((i+1)))
                  echo "  Field $i: '$field'"
              done
              return 1
          fi

          echo "Checksum verification succeeded."

          # Set the password for the local admin account if both guestlauid and guestlapw are set
          if [[ -f "$decrypted_keys_dir/guestlauid" && -f "$decrypted_keys_dir/guestlapw" ]]; then
              local_admin_user=$(cat "$decrypted_keys_dir/guestlauid")
              local_admin_password=$(cat "$decrypted_keys_dir/guestlapw")

              if [[ -n "$local_admin_user" && -n "$local_admin_password" ]]; then
                  if id "$local_admin_user" &>/dev/null; then
                      echo "$local_admin_user:$local_admin_password" | chpasswd
                      echo "Updated password for existing user: $local_admin_user"
                  else
                      useradd -m -s /bin/bash "$local_admin_user"
                      echo "$local_admin_user:$local_admin_password" | chpasswd
                      # Add to sudo group
                      usermod -aG sudo "$local_admin_user" 2>/dev/null || usermod -aG wheel "$local_admin_user" 2>/dev/null || true
                      echo "Created local admin account: $local_admin_user"
                  fi
              else
                  echo "WARNING: Local admin credentials are empty"
              fi
          else
              echo "INFO: Local admin account not configured (credentials not provided)"
          fi

          # Ignore domain join parameters
          if [[ -f "$decrypted_keys_dir/guestdomainjointarget" || -f "$decrypted_keys_dir/guestdomainjoinuid" || -f "$decrypted_keys_dir/guestdomainjoinpw" ]]; then
              echo "Domain join parameters detected but ignored (not supported on Linux)."
          fi

          # Configure the network with netplan if IP settings are set
          if [[ -f "$decrypted_keys_dir/guestv4ipaddr" && -f "$decrypted_keys_dir/guestv4cidrprefix" && -f "$decrypted_keys_dir/guestv4defaultgw" ]]; then
              ip_address=$(cat "$decrypted_keys_dir/guestv4ipaddr")
              cidr_prefix=$(cat "$decrypted_keys_dir/guestv4cidrprefix")
              default_gateway=$(cat "$decrypted_keys_dir/guestv4defaultgw")
              dns1=$(cat "$decrypted_keys_dir/guestv4dns1")
              dns2=$(cat "$decrypted_keys_dir/guestv4dns2")
              dns_suffix=$(cat "$decrypted_keys_dir/guestnetdnssuffix")

              netplan_config="/etc/netplan/01-netcfg.yaml"
              cat > "$netplan_config" <<EOF
      network:
        version: 2
        ethernets:
          eth0:
            dhcp4: no
            addresses:
              - $ip_address/$cidr_prefix
            gateway4: $default_gateway
            nameservers:
              addresses:
                - $dns1
                - $dns2
              search:
                - $dns_suffix
      EOF
              netplan apply
              echo "Network configured with netplan."
          fi

          # Set the hostname if it is set
          if [[ -f "$decrypted_keys_dir/guesthostname" ]]; then
              hostname=$(cat "$decrypted_keys_dir/guesthostname")
              echo "$hostname" > /etc/hostname
              hostnamectl set-hostname "$hostname"
              echo "Hostname set to $hostname."
          fi
          echo "Phase one completed."
          reboot
      }

      phase_two() {
          echo "Starting phase two..."
          update_phase_status "phase_two"

          # Delete the decrypted KVP data folder
          decrypted_keys_dir="/var/lib/hyperv/decrypted_keys"
          if [[ -d "$decrypted_keys_dir" ]]; then
              rm -rf "$decrypted_keys_dir"
              echo "Deleted decrypted KVP data folder: $decrypted_keys_dir"
          fi

          # Delete the service and copied script
          SERVICE_NAME="provisioning.service"
          TARGET_PATH="/usr/local/bin"
          SCRIPT_NAME="ProvisioningService.sh"

          echo "Phase two completed."

          systemctl disable "$SERVICE_NAME"
          (sleep 2 && systemctl stop "$SERVICE_NAME") &
          rm -f "/etc/systemd/system/$SERVICE_NAME"
          rm -f "$TARGET_PATH/$SCRIPT_NAME"
          systemctl daemon-reload
          echo "Deleted service and copied script."
      }

      read_phase_status
      case "$current_phase" in
          "nophasestartedyet")
              phase_one
              ;;
          "phase_one")
              phase_two
              ;;
          "phase_two")
              echo "All phases are already completed."
              ;;
          *)
              echo "Unknown phase status: $current_phase"
              ;;
      esac

# 2. Write the systemd service unit
  - path: /etc/systemd/system/provisioning.service
    permissions: '0644'
    owner: root:root
    content: |
      [Unit]
      Description=Provisioning Service
      After=network.target

      [Service]
      Type=simple
      ExecStart=/usr/local/bin/provisioning-service.sh
      Restart=on-failure
      User=root

      [Install]
      WantedBy=multi-user.target

# 3. Start provisioning service
runcmd:
  # Wait a moment for KVP daemon to initialize
  - sleep 5
  - systemctl daemon-reload
  - systemctl enable provisioning.service
  - systemctl start provisioning.service
